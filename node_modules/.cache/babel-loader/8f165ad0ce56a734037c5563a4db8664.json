{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { ISubscription } from \"@walletconnect/types\";\nimport { ERROR } from \"@walletconnect/utils\";\nimport { CLIENT_BEAT_INTERVAL, CLIENT_EVENTS, RELAYER_EVENTS, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS } from \"../constants\";\nimport { generateChildLogger, getLoggerContext } from \"@pedrouid/pino-utils\";\nexport class Subscription extends ISubscription {\n  constructor(client, logger, context) {\n    super(client, logger, context);\n    this.client = client;\n    this.logger = logger;\n    this.context = context;\n    this.subscriptions = new Map();\n    this.events = new EventEmitter();\n    this.timeout = new Map();\n    this.cached = [];\n    this.logger = generateChildLogger(logger, this.context);\n    this.registerEventListeners();\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.restore();\n  }\n\n  get length() {\n    return this.subscriptions.size;\n  }\n\n  get topics() {\n    return Array.from(this.subscriptions.keys());\n  }\n\n  get values() {\n    return Array.from(this.subscriptions.values());\n  }\n\n  async set(topic, data, opts) {\n    await this.isEnabled();\n\n    if (this.subscriptions.has(topic)) {\n      this.update(topic, data);\n    } else {\n      this.logger.debug(`Setting subscription`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"set\",\n        topic,\n        data,\n        opts\n      });\n      await this.subscribeAndSet(topic, data, opts);\n      this.events.emit(SUBSCRIPTION_EVENTS.created, {\n        topic,\n        data\n      });\n    }\n  }\n\n  async get(topic) {\n    await this.isEnabled();\n    this.logger.debug(`Getting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"get\",\n      topic\n    });\n    const subscription = await this.getSubscription(topic);\n    return subscription.data;\n  }\n\n  async update(topic, update) {\n    await this.isEnabled();\n    this.logger.debug(`Updating subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"update\",\n      topic,\n      update\n    });\n    const subscription = await this.getSubscription(topic);\n    const data = Object.assign(Object.assign({}, subscription.data), update);\n    this.subscriptions.set(topic, Object.assign(Object.assign({}, subscription), {\n      topic,\n      data\n    }));\n    this.events.emit(SUBSCRIPTION_EVENTS.updated, {\n      topic,\n      data,\n      update\n    });\n  }\n\n  async delete(topic, reason) {\n    await this.isEnabled();\n    this.logger.debug(`Deleting subscription`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"delete\",\n      topic,\n      reason\n    });\n    const subscription = await this.getSubscription(topic);\n    this.subscriptions.delete(topic);\n    await this.client.relayer.unsubscribe(subscription.id, {\n      relay: subscription.relay\n    });\n    this.events.emit(SUBSCRIPTION_EVENTS.deleted, {\n      topic,\n      data: subscription.data,\n      reason\n    });\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  async onPayload(payloadEvent) {\n    this.events.emit(SUBSCRIPTION_EVENTS.payload, payloadEvent);\n  }\n\n  getNestedContext(length) {\n    const nestedContext = getLoggerContext(this.logger).split(\"/\");\n    return nestedContext.slice(nestedContext.length - length, nestedContext.length);\n  }\n\n  getSubscriptionContext() {\n    return this.getNestedContext(2).join(\" \");\n  }\n\n  getStorageKey() {\n    const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;\n    const subscriptionContext = this.getNestedContext(2).join(\":\");\n    return `${storageKeyPrefix}//${subscriptionContext}`;\n  }\n\n  async getSubscription(topic) {\n    await this.isEnabled();\n    const subscription = this.subscriptions.get(topic);\n\n    if (!subscription) {\n      const error = ERROR.NO_MATCHING_TOPIC.format({\n        context: this.getSubscriptionContext(),\n        topic\n      });\n      this.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    return subscription;\n  }\n\n  async subscribeAndSet(topic, data, opts) {\n    const id = await this.client.relayer.subscribe(topic, payload => this.onPayload({\n      topic,\n      payload\n    }), opts);\n    const expiry = opts.expiry || Date.now() + SUBSCRIPTION_DEFAULT_TTL * 1000;\n    this.subscriptions.set(topic, Object.assign(Object.assign({\n      id,\n      topic,\n      data\n    }, opts), {\n      expiry\n    }));\n    this.setTimeout(topic, expiry);\n  }\n\n  setTimeout(topic, expiry) {\n    if (this.timeout.has(topic)) return;\n    const ttl = expiry - Date.now();\n\n    if (ttl <= 0) {\n      this.onTimeout(topic);\n      return;\n    }\n\n    if (ttl > CLIENT_BEAT_INTERVAL) return;\n    const timeout = setTimeout(() => this.onTimeout(topic), ttl);\n    this.timeout.set(topic, timeout);\n  }\n\n  deleteTimeout(topic) {\n    if (!this.timeout.has(topic)) return;\n    const timeout = this.timeout.get(topic);\n    if (typeof timeout === \"undefined\") return;\n    clearTimeout(timeout);\n  }\n\n  resetTimeout() {\n    this.timeout.forEach(timeout => clearTimeout(timeout));\n    this.timeout.clear();\n  }\n\n  onTimeout(topic) {\n    this.deleteTimeout(topic);\n    this.delete(topic, ERROR.EXPIRED.format({\n      context: this.getSubscriptionContext()\n    }));\n  }\n\n  checkSubscriptions() {\n    this.subscriptions.forEach(subscription => this.setTimeout(subscription.topic, subscription.expiry));\n  }\n\n  async persist() {\n    await this.client.storage.setItem(this.getStorageKey(), this.values);\n    this.events.emit(SUBSCRIPTION_EVENTS.sync);\n  }\n\n  async restore() {\n    try {\n      const persisted = await this.client.storage.getItem(this.getStorageKey());\n      if (typeof persisted === \"undefined\") return;\n      if (!persisted.length) return;\n\n      if (this.subscriptions.size) {\n        const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n          context: this.getSubscriptionContext()\n        });\n        this.logger.error(error.message);\n        throw new Error(error.message);\n      }\n\n      this.cached = persisted;\n      await Promise.all(this.cached.map(async subscription => {\n        const {\n          topic,\n          data\n        } = subscription;\n        const opts = {\n          relay: subscription.relay,\n          expiry: subscription.expiry\n        };\n        await this.subscribeAndSet(topic, data, opts);\n      }));\n      await this.enable();\n      this.logger.debug(`Successfully Restored subscriptions for ${this.getSubscriptionContext()}`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"restore\",\n        subscriptions: this.values\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Restore subscriptions for ${this.getSubscriptionContext()}`);\n      this.logger.error(e);\n    }\n  }\n\n  async reset() {\n    await this.disable();\n    await Promise.all(this.cached.map(async subscription => {\n      const {\n        topic,\n        data\n      } = subscription;\n      const opts = {\n        relay: subscription.relay,\n        expiry: subscription.expiry\n      };\n      await this.subscribeAndSet(topic, data, opts);\n    }));\n    await this.enable();\n  }\n\n  async isEnabled() {\n    if (!this.cached.length) return;\n    return new Promise(resolve => {\n      this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());\n    });\n  }\n\n  async enable() {\n    this.cached = [];\n    this.events.emit(SUBSCRIPTION_EVENTS.enabled);\n  }\n\n  async disable() {\n    if (!this.cached.length) {\n      this.cached = this.values;\n    }\n\n    this.resetTimeout();\n    this.events.emit(SUBSCRIPTION_EVENTS.disabled);\n  }\n\n  registerEventListeners() {\n    this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());\n    this.client.relayer.on(RELAYER_EVENTS.connect, () => this.reset());\n    this.events.on(SUBSCRIPTION_EVENTS.payload, payloadEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.payload;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: payloadEvent\n      });\n    });\n    this.events.on(SUBSCRIPTION_EVENTS.created, createdEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.created;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: createdEvent\n      });\n      this.persist();\n    });\n    this.events.on(SUBSCRIPTION_EVENTS.updated, updatedEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.updated;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: updatedEvent\n      });\n      this.persist();\n    });\n    this.events.on(SUBSCRIPTION_EVENTS.deleted, deletedEvent => {\n      const eventName = SUBSCRIPTION_EVENTS.deleted;\n      this.logger.info(`Emitting ${eventName}`);\n      this.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: deletedEvent\n      });\n      this.persist();\n    });\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/subscription.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { ISubscription, } from \"@walletconnect/types\";\nimport { ERROR } from \"@walletconnect/utils\";\nimport { CLIENT_BEAT_INTERVAL, CLIENT_EVENTS, RELAYER_EVENTS, SUBSCRIPTION_DEFAULT_TTL, SUBSCRIPTION_EVENTS, } from \"../constants\";\nimport { generateChildLogger, getLoggerContext } from \"@pedrouid/pino-utils\";\nexport class Subscription extends ISubscription {\n    constructor(client, logger, context) {\n        super(client, logger, context);\n        this.client = client;\n        this.logger = logger;\n        this.context = context;\n        this.subscriptions = new Map();\n        this.events = new EventEmitter();\n        this.timeout = new Map();\n        this.cached = [];\n        this.logger = generateChildLogger(logger, this.context);\n        this.registerEventListeners();\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.restore();\n    }\n    get length() {\n        return this.subscriptions.size;\n    }\n    get topics() {\n        return Array.from(this.subscriptions.keys());\n    }\n    get values() {\n        return Array.from(this.subscriptions.values());\n    }\n    async set(topic, data, opts) {\n        await this.isEnabled();\n        if (this.subscriptions.has(topic)) {\n            this.update(topic, data);\n        }\n        else {\n            this.logger.debug(`Setting subscription`);\n            this.logger.trace({ type: \"method\", method: \"set\", topic, data, opts });\n            await this.subscribeAndSet(topic, data, opts);\n            this.events.emit(SUBSCRIPTION_EVENTS.created, {\n                topic,\n                data,\n            });\n        }\n    }\n    async get(topic) {\n        await this.isEnabled();\n        this.logger.debug(`Getting subscription`);\n        this.logger.trace({ type: \"method\", method: \"get\", topic });\n        const subscription = await this.getSubscription(topic);\n        return subscription.data;\n    }\n    async update(topic, update) {\n        await this.isEnabled();\n        this.logger.debug(`Updating subscription`);\n        this.logger.trace({ type: \"method\", method: \"update\", topic, update });\n        const subscription = await this.getSubscription(topic);\n        const data = Object.assign(Object.assign({}, subscription.data), update);\n        this.subscriptions.set(topic, Object.assign(Object.assign({}, subscription), { topic,\n            data }));\n        this.events.emit(SUBSCRIPTION_EVENTS.updated, {\n            topic,\n            data,\n            update,\n        });\n    }\n    async delete(topic, reason) {\n        await this.isEnabled();\n        this.logger.debug(`Deleting subscription`);\n        this.logger.trace({ type: \"method\", method: \"delete\", topic, reason });\n        const subscription = await this.getSubscription(topic);\n        this.subscriptions.delete(topic);\n        await this.client.relayer.unsubscribe(subscription.id, {\n            relay: subscription.relay,\n        });\n        this.events.emit(SUBSCRIPTION_EVENTS.deleted, {\n            topic,\n            data: subscription.data,\n            reason,\n        });\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    async onPayload(payloadEvent) {\n        this.events.emit(SUBSCRIPTION_EVENTS.payload, payloadEvent);\n    }\n    getNestedContext(length) {\n        const nestedContext = getLoggerContext(this.logger).split(\"/\");\n        return nestedContext.slice(nestedContext.length - length, nestedContext.length);\n    }\n    getSubscriptionContext() {\n        return this.getNestedContext(2).join(\" \");\n    }\n    getStorageKey() {\n        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;\n        const subscriptionContext = this.getNestedContext(2).join(\":\");\n        return `${storageKeyPrefix}//${subscriptionContext}`;\n    }\n    async getSubscription(topic) {\n        await this.isEnabled();\n        const subscription = this.subscriptions.get(topic);\n        if (!subscription) {\n            const error = ERROR.NO_MATCHING_TOPIC.format({\n                context: this.getSubscriptionContext(),\n                topic,\n            });\n            this.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        return subscription;\n    }\n    async subscribeAndSet(topic, data, opts) {\n        const id = await this.client.relayer.subscribe(topic, (payload) => this.onPayload({ topic, payload }), opts);\n        const expiry = opts.expiry || Date.now() + SUBSCRIPTION_DEFAULT_TTL * 1000;\n        this.subscriptions.set(topic, Object.assign(Object.assign({ id, topic, data }, opts), { expiry }));\n        this.setTimeout(topic, expiry);\n    }\n    setTimeout(topic, expiry) {\n        if (this.timeout.has(topic))\n            return;\n        const ttl = expiry - Date.now();\n        if (ttl <= 0) {\n            this.onTimeout(topic);\n            return;\n        }\n        if (ttl > CLIENT_BEAT_INTERVAL)\n            return;\n        const timeout = setTimeout(() => this.onTimeout(topic), ttl);\n        this.timeout.set(topic, timeout);\n    }\n    deleteTimeout(topic) {\n        if (!this.timeout.has(topic))\n            return;\n        const timeout = this.timeout.get(topic);\n        if (typeof timeout === \"undefined\")\n            return;\n        clearTimeout(timeout);\n    }\n    resetTimeout() {\n        this.timeout.forEach(timeout => clearTimeout(timeout));\n        this.timeout.clear();\n    }\n    onTimeout(topic) {\n        this.deleteTimeout(topic);\n        this.delete(topic, ERROR.EXPIRED.format({ context: this.getSubscriptionContext() }));\n    }\n    checkSubscriptions() {\n        this.subscriptions.forEach(subscription => this.setTimeout(subscription.topic, subscription.expiry));\n    }\n    async persist() {\n        await this.client.storage.setItem(this.getStorageKey(), this.values);\n        this.events.emit(SUBSCRIPTION_EVENTS.sync);\n    }\n    async restore() {\n        try {\n            const persisted = await this.client.storage.getItem(this.getStorageKey());\n            if (typeof persisted === \"undefined\")\n                return;\n            if (!persisted.length)\n                return;\n            if (this.subscriptions.size) {\n                const error = ERROR.RESTORE_WILL_OVERRIDE.format({\n                    context: this.getSubscriptionContext(),\n                });\n                this.logger.error(error.message);\n                throw new Error(error.message);\n            }\n            this.cached = persisted;\n            await Promise.all(this.cached.map(async (subscription) => {\n                const { topic, data } = subscription;\n                const opts = {\n                    relay: subscription.relay,\n                    expiry: subscription.expiry,\n                };\n                await this.subscribeAndSet(topic, data, opts);\n            }));\n            await this.enable();\n            this.logger.debug(`Successfully Restored subscriptions for ${this.getSubscriptionContext()}`);\n            this.logger.trace({ type: \"method\", method: \"restore\", subscriptions: this.values });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Restore subscriptions for ${this.getSubscriptionContext()}`);\n            this.logger.error(e);\n        }\n    }\n    async reset() {\n        await this.disable();\n        await Promise.all(this.cached.map(async (subscription) => {\n            const { topic, data } = subscription;\n            const opts = {\n                relay: subscription.relay,\n                expiry: subscription.expiry,\n            };\n            await this.subscribeAndSet(topic, data, opts);\n        }));\n        await this.enable();\n    }\n    async isEnabled() {\n        if (!this.cached.length)\n            return;\n        return new Promise(resolve => {\n            this.events.once(SUBSCRIPTION_EVENTS.enabled, () => resolve());\n        });\n    }\n    async enable() {\n        this.cached = [];\n        this.events.emit(SUBSCRIPTION_EVENTS.enabled);\n    }\n    async disable() {\n        if (!this.cached.length) {\n            this.cached = this.values;\n        }\n        this.resetTimeout();\n        this.events.emit(SUBSCRIPTION_EVENTS.disabled);\n    }\n    registerEventListeners() {\n        this.client.on(CLIENT_EVENTS.beat, () => this.checkSubscriptions());\n        this.client.relayer.on(RELAYER_EVENTS.connect, () => this.reset());\n        this.events.on(SUBSCRIPTION_EVENTS.payload, (payloadEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.payload;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: payloadEvent });\n        });\n        this.events.on(SUBSCRIPTION_EVENTS.created, (createdEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.created;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: createdEvent });\n            this.persist();\n        });\n        this.events.on(SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.updated;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: updatedEvent });\n            this.persist();\n        });\n        this.events.on(SUBSCRIPTION_EVENTS.deleted, (deletedEvent) => {\n            const eventName = SUBSCRIPTION_EVENTS.deleted;\n            this.logger.info(`Emitting ${eventName}`);\n            this.logger.debug({ type: \"event\", event: eventName, data: deletedEvent });\n            this.persist();\n        });\n    }\n}\n//# sourceMappingURL=subscription.js.map"]},"metadata":{},"sourceType":"module"}