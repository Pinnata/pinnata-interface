{"ast":null,"code":"import { ERROR, mapToObj, objToMap, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256 } from \"@walletconnect/utils\";\nimport { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from \"../constants\";\nimport { arrayToHex, concatArrays, hexToArray } from \"enc-utils\";\nexport class KeyChain {\n  constructor(client, storage) {\n    this.client = client;\n    this.storage = storage;\n    this.keychain = new Map();\n    this.context = KEYCHAIN_CONTEXT;\n    this.client = client;\n    this.storage = storage;\n  }\n\n  async init() {\n    await this.restore();\n  }\n\n  async has(tag, opts) {\n    return this.keychain.has(tag);\n  }\n\n  async set(tag, key, opts) {\n    this.keychain.set(tag, key);\n    await this.persist();\n  }\n\n  async get(tag, opts) {\n    const key = this.keychain.get(tag);\n\n    if (typeof key === \"undefined\") {\n      throw new Error(ERROR.NO_MATCHING_KEY.format({\n        tag\n      }).message);\n    }\n\n    return key;\n  }\n\n  async del(tag, opts) {\n    this.keychain.delete(tag);\n    await this.persist();\n  }\n\n  getStorageKey() {\n    const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;\n    return `${storageKeyPrefix}//${this.context}`;\n  }\n\n  async restore() {\n    const persisted = await this.storage.getItem(this.getStorageKey());\n\n    if (typeof persisted !== \"undefined\") {\n      this.keychain = objToMap(persisted);\n    }\n  }\n\n  async persist() {\n    await this.storage.setItem(this.getStorageKey(), mapToObj(this.keychain));\n  }\n\n}\nexport class Crypto {\n  constructor(client, keychain) {\n    this.client = client;\n    this.keychain = keychain;\n    this.context = CRYPTO_CONTEXT;\n    this.client = client;\n    this.keychain = keychain;\n  }\n\n  async init() {\n    await this.keychain.init();\n  }\n\n  async hasKeys(tag) {\n    return this.keychain.has(tag);\n  }\n\n  async generateKeyPair() {\n    const keyPair = generateKeyPair();\n    return this.setKeyPair(keyPair);\n  }\n\n  async generateSharedKey(self, peer, overrideTopic) {\n    const keyPair = await this.getKeyPair(self.publicKey);\n    const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);\n    return this.setEncryptionKeys({\n      sharedKey,\n      publicKey: keyPair.publicKey\n    }, overrideTopic);\n  }\n\n  async encrypt(topic, message) {\n    const {\n      sharedKey,\n      publicKey\n    } = await this.getEncryptionKeys(topic);\n    const result = await encrypt({\n      message,\n      sharedKey,\n      publicKey\n    });\n    return result;\n  }\n\n  async decrypt(topic, encrypted) {\n    const {\n      sharedKey\n    } = await this.getEncryptionKeys(topic);\n    const result = await decrypt({\n      encrypted,\n      sharedKey\n    });\n    return result;\n  }\n\n  concatKeys(keyA, keyB) {\n    return arrayToHex(concatArrays(hexToArray(keyA), hexToArray(keyB)));\n  }\n\n  splitKeys(keys) {\n    const arr = hexToArray(keys);\n    return [arrayToHex(arr.slice(0, 32)), arrayToHex(arr.slice(32, 64))];\n  }\n\n  async setKeyPair(keyPair) {\n    const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);\n    await this.keychain.set(keyPair.publicKey, keys);\n    return keyPair.publicKey;\n  }\n\n  async getKeyPair(publicKey) {\n    const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));\n    return {\n      publicKey,\n      privateKey\n    };\n  }\n\n  async setEncryptionKeys(encryptionKeys, overrideTopic) {\n    const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));\n    const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);\n    await this.keychain.set(topic, keys);\n    return topic;\n  }\n\n  async getEncryptionKeys(topic) {\n    const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));\n    return {\n      sharedKey,\n      publicKey\n    };\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/crypto.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { ERROR, mapToObj, objToMap, generateKeyPair, deriveSharedKey, encrypt, decrypt, sha256, } from \"@walletconnect/utils\";\nimport { CRYPTO_CONTEXT, KEYCHAIN_CONTEXT } from \"../constants\";\nimport { arrayToHex, concatArrays, hexToArray } from \"enc-utils\";\nexport class KeyChain {\n    constructor(client, storage) {\n        this.client = client;\n        this.storage = storage;\n        this.keychain = new Map();\n        this.context = KEYCHAIN_CONTEXT;\n        this.client = client;\n        this.storage = storage;\n    }\n    async init() {\n        await this.restore();\n    }\n    async has(tag, opts) {\n        return this.keychain.has(tag);\n    }\n    async set(tag, key, opts) {\n        this.keychain.set(tag, key);\n        await this.persist();\n    }\n    async get(tag, opts) {\n        const key = this.keychain.get(tag);\n        if (typeof key === \"undefined\") {\n            throw new Error(ERROR.NO_MATCHING_KEY.format({ tag }).message);\n        }\n        return key;\n    }\n    async del(tag, opts) {\n        this.keychain.delete(tag);\n        await this.persist();\n    }\n    getStorageKey() {\n        const storageKeyPrefix = `${this.client.protocol}@${this.client.version}:${this.client.context}`;\n        return `${storageKeyPrefix}//${this.context}`;\n    }\n    async restore() {\n        const persisted = await this.storage.getItem(this.getStorageKey());\n        if (typeof persisted !== \"undefined\") {\n            this.keychain = objToMap(persisted);\n        }\n    }\n    async persist() {\n        await this.storage.setItem(this.getStorageKey(), mapToObj(this.keychain));\n    }\n}\nexport class Crypto {\n    constructor(client, keychain) {\n        this.client = client;\n        this.keychain = keychain;\n        this.context = CRYPTO_CONTEXT;\n        this.client = client;\n        this.keychain = keychain;\n    }\n    async init() {\n        await this.keychain.init();\n    }\n    async hasKeys(tag) {\n        return this.keychain.has(tag);\n    }\n    async generateKeyPair() {\n        const keyPair = generateKeyPair();\n        return this.setKeyPair(keyPair);\n    }\n    async generateSharedKey(self, peer, overrideTopic) {\n        const keyPair = await this.getKeyPair(self.publicKey);\n        const sharedKey = deriveSharedKey(keyPair.privateKey, peer.publicKey);\n        return this.setEncryptionKeys({ sharedKey, publicKey: keyPair.publicKey }, overrideTopic);\n    }\n    async encrypt(topic, message) {\n        const { sharedKey, publicKey } = await this.getEncryptionKeys(topic);\n        const result = await encrypt({ message, sharedKey, publicKey });\n        return result;\n    }\n    async decrypt(topic, encrypted) {\n        const { sharedKey } = await this.getEncryptionKeys(topic);\n        const result = await decrypt({ encrypted, sharedKey });\n        return result;\n    }\n    concatKeys(keyA, keyB) {\n        return arrayToHex(concatArrays(hexToArray(keyA), hexToArray(keyB)));\n    }\n    splitKeys(keys) {\n        const arr = hexToArray(keys);\n        return [arrayToHex(arr.slice(0, 32)), arrayToHex(arr.slice(32, 64))];\n    }\n    async setKeyPair(keyPair) {\n        const keys = this.concatKeys(keyPair.publicKey, keyPair.privateKey);\n        await this.keychain.set(keyPair.publicKey, keys);\n        return keyPair.publicKey;\n    }\n    async getKeyPair(publicKey) {\n        const [_, privateKey] = this.splitKeys(await this.keychain.get(publicKey));\n        return { publicKey, privateKey };\n    }\n    async setEncryptionKeys(encryptionKeys, overrideTopic) {\n        const topic = overrideTopic || (await sha256(encryptionKeys.sharedKey));\n        const keys = this.concatKeys(encryptionKeys.sharedKey, encryptionKeys.publicKey);\n        await this.keychain.set(topic, keys);\n        return topic;\n    }\n    async getEncryptionKeys(topic) {\n        const [sharedKey, publicKey] = this.splitKeys(await this.keychain.get(topic));\n        return { sharedKey, publicKey };\n    }\n}\n//# sourceMappingURL=crypto.js.map"]},"metadata":{},"sourceType":"module"}