{"ast":null,"code":"import { IEngine } from \"@walletconnect/types\";\nimport { generateRandomBytes32, isSignalTypePairing, isSequenceFailed, isSequenceResponded, isSubscriptionUpdatedEvent, ERROR } from \"@walletconnect/utils\";\nimport { formatJsonRpcError, formatJsonRpcRequest, formatJsonRpcResult, isJsonRpcError, isJsonRpcRequest } from \"@json-rpc-tools/utils\";\nimport { SUBSCRIPTION_EVENTS, RELAYER_DEFAULT_PROTOCOL, FIVE_MINUTES, THIRTY_SECONDS } from \"../constants\";\nexport class Engine extends IEngine {\n  constructor(sequence) {\n    super(sequence);\n    this.sequence = sequence;\n    this.sequence = sequence;\n    this.registerEventListeners();\n  }\n\n  async ping(topic, timeout) {\n    const request = {\n      method: this.sequence.config.jsonrpc.ping,\n      params: {}\n    };\n    return this.request({\n      topic,\n      request,\n      timeout: timeout || THIRTY_SECONDS * 1000\n    });\n  }\n\n  async send(topic, payload, chainId) {\n    const settled = await this.sequence.settled.get(topic);\n\n    if (isJsonRpcRequest(payload)) {\n      if (!Object.values(this.sequence.config.jsonrpc).includes(payload.method)) {\n        await this.isJsonRpcAuthorized(topic, settled.self, payload);\n        await this.sequence.validateRequest({\n          topic,\n          request: payload,\n          chainId\n        });\n        await this.sequence.history.set(topic, payload, chainId);\n        const params = {\n          chainId,\n          request: {\n            method: payload.method,\n            params: payload.params\n          }\n        };\n        if (!params.chainId) delete params.chainId;\n        payload = formatJsonRpcRequest(this.sequence.config.jsonrpc.payload, params, payload.id);\n      }\n    } else {\n      await this.sequence.history.update(topic, payload);\n    }\n\n    await this.sequence.client.relayer.publish(settled.topic, payload, {\n      relay: settled.relay\n    });\n  }\n\n  get length() {\n    return this.sequence.settled.length;\n  }\n\n  get topics() {\n    return this.sequence.settled.topics;\n  }\n\n  get values() {\n    return this.sequence.settled.values.map(x => x.data);\n  }\n\n  create(params) {\n    return new Promise(async (resolve, reject) => {\n      this.sequence.logger.debug(`Create ${this.sequence.context}`);\n      this.sequence.logger.trace({\n        type: \"method\",\n        method: \"create\",\n        params\n      });\n      const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || FIVE_MINUTES * 1000;\n      const timeout = setTimeout(() => {\n        const error = ERROR.SETTLE_TIMEOUT.format({\n          context: this.sequence.context,\n          timeout: maxTimeout\n        });\n        this.sequence.logger.error(error.message);\n        reject(error.message);\n      }, maxTimeout);\n      let pending;\n\n      try {\n        pending = await this.propose(params);\n      } catch (e) {\n        clearTimeout(timeout);\n        return reject(e);\n      }\n\n      this.sequence.pending.on(SUBSCRIPTION_EVENTS.updated, async updatedEvent => {\n        if (pending.topic !== updatedEvent.data.topic) return;\n\n        if (isSequenceResponded(updatedEvent.data)) {\n          const outcome = updatedEvent.data.outcome;\n          clearTimeout(timeout);\n\n          if (isSequenceFailed(outcome)) {\n            try {\n              await this.sequence.pending.delete(pending.topic, outcome.reason);\n            } catch (e) {\n              return reject(e);\n            }\n\n            reject(new Error(outcome.reason.message));\n          } else {\n            try {\n              const settled = await this.sequence.settled.get(outcome.topic);\n              const reason = ERROR.SETTLED.format({\n                context: this.sequence.context\n              });\n              await this.sequence.pending.delete(pending.topic, reason);\n              resolve(settled);\n            } catch (e) {\n              return reject(e);\n            }\n          }\n        }\n      });\n    });\n  }\n\n  async respond(params) {\n    this.sequence.logger.debug(`Respond ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"respond\",\n      params\n    });\n    await this.sequence.validateRespond(params);\n    const {\n      approved,\n      proposal,\n      response\n    } = params;\n    const {\n      relay,\n      ttl\n    } = proposal;\n    const self = {\n      publicKey: await this.sequence.client.crypto.generateKeyPair(),\n      metadata: response === null || response === void 0 ? void 0 : response.metadata\n    };\n    if (!self.metadata) delete self.metadata;\n\n    if (approved) {\n      try {\n        const responder = {\n          publicKey: self.publicKey,\n          metadata: response === null || response === void 0 ? void 0 : response.metadata\n        };\n        if (!responder.metadata) delete responder.metadata;\n        const expiry = Date.now() + proposal.ttl * 1000;\n        const state = (response === null || response === void 0 ? void 0 : response.state) || {};\n        const peer = {\n          publicKey: proposal.proposer.publicKey,\n          metadata: proposal.proposer.metadata\n        };\n        if (!peer.metadata) delete peer.metadata;\n        const controller = proposal.proposer.controller ? {\n          publicKey: peer.publicKey\n        } : {\n          publicKey: self.publicKey\n        };\n        const permissions = Object.assign(Object.assign({}, proposal.permissions), {\n          controller\n        });\n        const settled = await this.settle({\n          relay,\n          self,\n          peer,\n          permissions,\n          state,\n          ttl,\n          expiry\n        });\n        const outcome = {\n          topic: settled.topic,\n          relay,\n          state,\n          responder,\n          expiry\n        };\n        const pending = {\n          status: this.sequence.config.status.responded,\n          topic: proposal.topic,\n          relay,\n          self,\n          proposal,\n          outcome\n        };\n        await this.sequence.pending.set(pending.topic, pending, {\n          relay: pending.relay\n        });\n        return pending;\n      } catch (e) {\n        const reason = ERROR.GENERIC.format({\n          message: e.message\n        });\n        const outcome = {\n          reason\n        };\n        const pending = {\n          status: this.sequence.config.status.responded,\n          topic: proposal.topic,\n          relay,\n          self,\n          proposal,\n          outcome\n        };\n        await this.sequence.pending.set(pending.topic, pending, {\n          relay: pending.relay\n        });\n        return pending;\n      }\n    } else {\n      const defaultReason = ERROR.NOT_APPROVED.format({\n        context: this.sequence.context\n      });\n      const outcome = {\n        reason: (params === null || params === void 0 ? void 0 : params.reason) || defaultReason\n      };\n      const pending = {\n        status: this.sequence.config.status.responded,\n        topic: proposal.topic,\n        relay,\n        self,\n        proposal,\n        outcome\n      };\n      await this.sequence.pending.set(pending.topic, pending, {\n        relay: pending.relay\n      });\n      return pending;\n    }\n  }\n\n  async update(params) {\n    this.sequence.logger.debug(`Update ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"update\",\n      params\n    });\n    const settled = await this.sequence.settled.get(params.topic);\n    const participant = {\n      publicKey: settled.self.publicKey\n    };\n    const update = await this.handleUpdate(params.topic, params, participant);\n    const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.update, update);\n    await this.send(settled.topic, request);\n    return settled;\n  }\n\n  async upgrade(params) {\n    this.sequence.logger.debug(`Upgrade ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"upgrade\",\n      params\n    });\n    const settled = await this.sequence.settled.get(params.topic);\n    const participant = {\n      publicKey: settled.self.publicKey\n    };\n    const upgrade = await this.handleUpgrade(params.topic, params, participant);\n    const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.upgrade, upgrade);\n    await this.send(settled.topic, request);\n    return settled;\n  }\n\n  async request(params) {\n    return new Promise(async (resolve, reject) => {\n      try {\n        await this.sequence.validateRequest(params);\n      } catch (e) {\n        return reject(e);\n      }\n\n      const request = formatJsonRpcRequest(params.request.method, params.request.params);\n      const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || FIVE_MINUTES * 1000;\n      const timeout = setTimeout(() => {\n        const error = ERROR.JSONRPC_REQUEST_TIMEOUT.format({\n          method: request.method,\n          timeout: maxTimeout\n        });\n        this.sequence.logger.error(error.message);\n        reject(error.message);\n      }, maxTimeout);\n      this.sequence.events.on(this.sequence.config.events.response, responseEvent => {\n        if (params.topic !== responseEvent.topic) return;\n        const response = responseEvent.response;\n        if (response.id !== request.id) return;\n        clearTimeout(timeout);\n\n        if (isJsonRpcError(response)) {\n          const errorMessage = response.error.message;\n          this.sequence.logger.error(errorMessage);\n          return reject(new Error(errorMessage));\n        }\n\n        return resolve(response.result);\n      });\n\n      try {\n        await this.send(params.topic, request, params === null || params === void 0 ? void 0 : params.chainId);\n      } catch (e) {\n        clearTimeout(timeout);\n        return reject(e);\n      }\n    });\n  }\n\n  async delete(params) {\n    this.sequence.logger.debug(`Delete ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"delete\",\n      params\n    });\n    await this.sequence.settled.delete(params.topic, params.reason);\n  }\n\n  async notify(params) {\n    const settled = await this.sequence.settled.get(params.topic);\n    await this.isNotificationAuthorized(params.topic, settled.self, params.type);\n    const notification = {\n      type: params.type,\n      data: params.data\n    };\n    const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.notification, notification);\n    await this.send(params.topic, request);\n  }\n\n  async propose(params) {\n    this.sequence.logger.debug(`Propose ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"propose\",\n      params\n    });\n    await this.sequence.validatePropose(params);\n    const relay = (params === null || params === void 0 ? void 0 : params.relay) || {\n      protocol: RELAYER_DEFAULT_PROTOCOL\n    };\n    const topic = generateRandomBytes32();\n    const self = {\n      publicKey: await this.sequence.client.crypto.generateKeyPair(),\n      metadata: params === null || params === void 0 ? void 0 : params.metadata\n    };\n    if (!self.metadata) delete self.metadata;\n    const proposer = {\n      publicKey: self.publicKey,\n      controller: this.sequence.client.controller,\n      metadata: self.metadata\n    };\n    if (!proposer.metadata) delete proposer.metadata;\n    const signal = (params === null || params === void 0 ? void 0 : params.signal) || (await this.sequence.getDefaultSignal({\n      topic,\n      relay,\n      proposer\n    }));\n    const permissions = (params === null || params === void 0 ? void 0 : params.permissions) || (await this.sequence.getDefaultPermissions());\n    const ttl = (params === null || params === void 0 ? void 0 : params.ttl) || (await this.sequence.getDefaultTTL());\n    const proposal = {\n      relay,\n      topic,\n      proposer,\n      signal,\n      permissions,\n      ttl\n    };\n    const pending = {\n      status: this.sequence.config.status.proposed,\n      topic: proposal.topic,\n      relay: proposal.relay,\n      self,\n      proposal\n    };\n    await this.sequence.pending.set(pending.topic, pending, {\n      relay\n    });\n    return pending;\n  }\n\n  async settle(params) {\n    this.sequence.logger.debug(`Settle ${this.sequence.context}`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"settle\",\n      params\n    });\n    const topic = await this.sequence.client.crypto.generateSharedKey(params.self, params.peer);\n    const settled = {\n      topic,\n      relay: params.relay,\n      self: params.self,\n      peer: params.peer,\n      permissions: params.permissions,\n      expiry: params.expiry,\n      state: params.state\n    };\n    await this.sequence.settled.set(settled.topic, settled, {\n      relay: settled.relay,\n      expiry: settled.expiry\n    });\n    return settled;\n  }\n\n  async onResponse(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    this.sequence.logger.debug(`Receiving ${this.sequence.context} response`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"onResponse\",\n      topic,\n      payload\n    });\n    const request = payload;\n    const outcome = request.params;\n    const pending = await this.sequence.pending.get(topic);\n    let error;\n\n    if (!isSequenceFailed(outcome)) {\n      try {\n        const controller = pending.proposal.proposer.controller ? {\n          publicKey: pending.proposal.proposer.publicKey\n        } : {\n          publicKey: outcome.responder.publicKey\n        };\n        const peer = {\n          publicKey: outcome.responder.publicKey,\n          metadata: outcome.responder.metadata\n        };\n        if (!peer.metadata) delete peer.metadata;\n        const state = outcome.state || {};\n        const permissions = Object.assign(Object.assign({}, pending.proposal.permissions), {\n          controller\n        });\n        const settled = await this.settle({\n          relay: pending.relay,\n          self: pending.self,\n          peer,\n          permissions,\n          ttl: pending.proposal.ttl,\n          expiry: outcome.expiry,\n          state\n        });\n        await this.sequence.pending.update(topic, {\n          status: this.sequence.config.status.responded,\n          outcome: {\n            topic: settled.topic,\n            relay: settled.relay,\n            responder: outcome.responder,\n            expiry: settled.expiry,\n            state: settled.state\n          }\n        });\n      } catch (e) {\n        this.sequence.logger.error(e);\n        error = ERROR.GENERIC.format({\n          message: e.message\n        });\n        await this.sequence.pending.update(topic, {\n          status: this.sequence.config.status.responded,\n          outcome: {\n            reason: error\n          }\n        });\n      }\n\n      const response = typeof error === \"undefined\" ? formatJsonRpcResult(request.id, true) : formatJsonRpcError(request.id, error);\n      await this.sequence.client.relayer.publish(pending.topic, response, {\n        relay: pending.relay\n      });\n    } else {\n      this.sequence.logger.error(outcome.reason);\n      await this.sequence.pending.update(topic, {\n        status: this.sequence.config.status.responded,\n        outcome: {\n          reason: outcome.reason\n        }\n      });\n    }\n  }\n\n  async onAcknowledge(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    this.sequence.logger.debug(`Receiving ${this.sequence.context} acknowledge`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"onAcknowledge\",\n      topic,\n      payload\n    });\n    const response = payload;\n    const pending = await this.sequence.pending.get(topic);\n    if (!isSequenceResponded(pending)) return;\n\n    if (isJsonRpcError(response) && !isSequenceFailed(pending.outcome)) {\n      await this.sequence.settled.delete(pending.outcome.topic, response.error);\n    }\n\n    const reason = ERROR.RESPONSE_ACKNOWLEDGED.format({\n      context: this.sequence.context\n    });\n    await this.sequence.pending.delete(topic, reason);\n  }\n\n  async onMessage(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    this.sequence.logger.debug(`Receiving ${this.sequence.context} message`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"onMessage\",\n      topic,\n      payload\n    });\n\n    if (isJsonRpcRequest(payload)) {\n      const request = payload;\n      const settled = await this.sequence.settled.get(payloadEvent.topic);\n      let error;\n\n      switch (request.method) {\n        case this.sequence.config.jsonrpc.payload:\n          await this.onPayload(payloadEvent);\n          break;\n\n        case this.sequence.config.jsonrpc.update:\n          await this.onUpdate(payloadEvent);\n          break;\n\n        case this.sequence.config.jsonrpc.upgrade:\n          await this.onUpgrade(payloadEvent);\n          break;\n\n        case this.sequence.config.jsonrpc.notification:\n          await this.onNotification(payloadEvent);\n          break;\n\n        case this.sequence.config.jsonrpc.delete:\n          await this.sequence.settled.delete(settled.topic, request.params.reason);\n          break;\n\n        case this.sequence.config.jsonrpc.ping:\n          await this.send(settled.topic, formatJsonRpcResult(request.id, true));\n          break;\n\n        default:\n          error = ERROR.UNKNOWN_JSONRPC_METHOD.format({\n            method: request.method\n          });\n          this.sequence.logger.error(error.message);\n          await this.send(settled.topic, formatJsonRpcError(request.id, error));\n          break;\n      }\n    } else {\n      this.onPayloadEvent(payloadEvent);\n    }\n  }\n\n  async onPayload(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n\n    if (isJsonRpcRequest(payload)) {\n      const {\n        id,\n        params\n      } = payload;\n      const {\n        chainId\n      } = params;\n      const request = formatJsonRpcRequest(params.request.method, params.request.params, id);\n      const settled = await this.sequence.settled.get(topic);\n      await this.isJsonRpcAuthorized(topic, settled.peer, request);\n      await this.sequence.validateRequest({\n        topic,\n        request,\n        chainId\n      });\n      const settledPayloadEvent = {\n        topic,\n        payload: request,\n        chainId\n      };\n      this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);\n      this.sequence.logger.trace(Object.assign({\n        type: \"method\",\n        method: \"onPayload\"\n      }, settledPayloadEvent));\n      this.onPayloadEvent(settledPayloadEvent);\n    } else {\n      const settledPayloadEvent = {\n        topic,\n        payload\n      };\n      this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);\n      this.sequence.logger.trace(Object.assign({\n        type: \"method\",\n        method: \"onPayload\"\n      }, settledPayloadEvent));\n      this.onPayloadEvent(settledPayloadEvent);\n    }\n  }\n\n  async onUpdate(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    this.sequence.logger.debug(`Receiving ${this.sequence.context} update`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"onUpdate\",\n      topic,\n      payload\n    });\n    const request = payloadEvent.payload;\n    const settled = await this.sequence.settled.get(payloadEvent.topic);\n\n    try {\n      const participant = {\n        publicKey: settled.peer.publicKey\n      };\n      await this.handleUpdate(topic, request.params, participant);\n      const response = formatJsonRpcResult(request.id, true);\n      await this.send(settled.topic, response);\n    } catch (e) {\n      this.sequence.logger.error(e);\n      const response = formatJsonRpcError(request.id, e.message);\n      await this.send(settled.topic, response);\n    }\n  }\n\n  async onUpgrade(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    this.sequence.logger.debug(`Receiving ${this.sequence.context} upgrade`);\n    this.sequence.logger.trace({\n      type: \"method\",\n      method: \"onUpgrade\",\n      topic,\n      payload\n    });\n    const request = payloadEvent.payload;\n    const settled = await this.sequence.settled.get(payloadEvent.topic);\n\n    try {\n      const participant = {\n        publicKey: settled.peer.publicKey\n      };\n      await this.handleUpgrade(topic, request.params, participant);\n      const response = formatJsonRpcResult(request.id, true);\n      await this.send(settled.topic, response);\n    } catch (e) {\n      this.sequence.logger.error(e);\n      const response = formatJsonRpcError(request.id, e.message);\n      await this.send(settled.topic, response);\n    }\n  }\n\n  async onNotification(event) {\n    const notification = event.payload.params;\n    const settled = await this.sequence.settled.get(event.topic);\n    await this.isNotificationAuthorized(event.topic, settled.peer, notification.type);\n    const notificationEvent = {\n      topic: event.topic,\n      type: notification.type,\n      data: notification.data\n    };\n    const eventName = this.sequence.config.events.notification;\n    this.sequence.logger.info(`Emitting ${eventName}`);\n    this.sequence.logger.debug({\n      type: \"event\",\n      event: eventName,\n      notificationEvent\n    });\n    this.sequence.events.emit(eventName, notificationEvent);\n  }\n\n  async handleUpdate(topic, update, participant) {\n    if (typeof update.state === \"undefined\") {\n      const error = ERROR.INVALID_UPDATE_REQUEST.format({\n        context: this.sequence.context\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    const settled = await this.sequence.settled.get(topic);\n\n    if (participant.publicKey !== settled.permissions.controller.publicKey) {\n      const error = ERROR.UNAUTHORIZED_UPDATE_REQUEST.format({\n        context: this.sequence.context\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    settled.state = await this.sequence.mergeUpdate(topic, update);\n    await this.sequence.settled.update(settled.topic, settled);\n    return update;\n  }\n\n  async handleUpgrade(topic, upgrade, participant) {\n    if (typeof upgrade.permissions === \"undefined\") {\n      const error = ERROR.INVALID_UPGRADE_REQUEST.format({\n        context: this.sequence.context\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    const settled = await this.sequence.settled.get(topic);\n\n    if (participant.publicKey !== settled.permissions.controller.publicKey) {\n      const error = ERROR.UNAUTHORIZED_UPGRADE_REQUEST.format({\n        context: this.sequence.context\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n\n    settled.permissions = await this.sequence.mergeUpgrade(topic, upgrade);\n    await this.sequence.settled.update(settled.topic, settled);\n    return upgrade;\n  }\n\n  async isJsonRpcAuthorized(topic, participant, request) {\n    const settled = await this.sequence.settled.get(topic);\n    if (participant.publicKey === settled.permissions.controller.publicKey) return;\n\n    if (!settled.permissions.jsonrpc.methods.includes(request.method)) {\n      const error = ERROR.UNAUTHORIZED_JSON_RPC_METHOD.format({\n        method: request.method\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n  }\n\n  async isNotificationAuthorized(topic, participant, type) {\n    const settled = await this.sequence.settled.get(topic);\n    if (participant.publicKey === settled.permissions.controller.publicKey) return;\n\n    if (settled.self.publicKey !== settled.permissions.controller.publicKey && !settled.permissions.notifications.types.includes(type)) {\n      const error = ERROR.UNAUTHORIZED_NOTIFICATION_TYPE.format({\n        type\n      });\n      this.sequence.logger.error(error.message);\n      throw new Error(error.message);\n    }\n  }\n\n  async shouldIgnorePayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload\n    } = payloadEvent;\n    if (!this.sequence.settled.subscriptions.has(topic)) return true;\n    let exists = false;\n\n    try {\n      exists = await this.sequence.history.exists(topic, payload.id);\n    } catch (e) {}\n\n    return exists;\n  }\n\n  async onPayloadEvent(payloadEvent) {\n    const {\n      topic,\n      payload,\n      chainId\n    } = payloadEvent;\n\n    if (isJsonRpcRequest(payload)) {\n      if (await this.shouldIgnorePayloadEvent(payloadEvent)) return;\n      await this.sequence.history.set(topic, payload, chainId);\n    } else {\n      await this.sequence.history.update(topic, payload);\n    }\n\n    if (isJsonRpcRequest(payload)) {\n      const requestEvent = {\n        topic,\n        request: payload,\n        chainId\n      };\n      const eventName = this.sequence.config.events.request;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: requestEvent\n      });\n      this.sequence.events.emit(eventName, requestEvent);\n    } else {\n      const responseEvent = {\n        topic,\n        response: payload,\n        chainId\n      };\n      const eventName = this.sequence.config.events.response;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: responseEvent\n      });\n      this.sequence.events.emit(eventName, responseEvent);\n    }\n  }\n\n  async onPendingPayloadEvent(event) {\n    if (isJsonRpcRequest(event.payload)) {\n      switch (event.payload.method) {\n        case this.sequence.config.jsonrpc.approve:\n        case this.sequence.config.jsonrpc.reject:\n          this.onResponse(event);\n          break;\n\n        default:\n          break;\n      }\n    } else {\n      this.onAcknowledge(event);\n    }\n  }\n\n  async onPendingStatusEvent(event) {\n    const pending = event.data;\n\n    if (isSignalTypePairing(pending.proposal.signal)) {\n      if (!(await this.sequence.client.crypto.hasKeys(pending.proposal.topic))) {\n        const pairing = await this.sequence.client.pairing.settled.get(pending.proposal.signal.params.topic);\n        await this.sequence.client.crypto.generateSharedKey(pairing.self, pairing.peer, pending.proposal.topic);\n      }\n    }\n\n    if (isSequenceResponded(pending)) {\n      const eventName = this.sequence.config.events.responded;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: pending\n      });\n      this.sequence.events.emit(eventName, pending);\n\n      if (!isSubscriptionUpdatedEvent(event)) {\n        const method = !isSequenceFailed(pending.outcome) ? this.sequence.config.jsonrpc.approve : this.sequence.config.jsonrpc.reject;\n        const request = formatJsonRpcRequest(method, pending.outcome);\n        await this.sequence.client.relayer.publish(pending.topic, request, {\n          relay: pending.relay\n        });\n      }\n    } else {\n      const eventName = this.sequence.config.events.proposed;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: pending\n      });\n      this.sequence.events.emit(eventName, pending);\n\n      if (isSignalTypePairing(pending.proposal.signal)) {\n        const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.propose, pending.proposal);\n        await this.sequence.client.pairing.send(pending.proposal.signal.params.topic, request);\n      }\n    }\n  }\n\n  registerEventListeners() {\n    this.sequence.pending.on(SUBSCRIPTION_EVENTS.payload, payloadEvent => this.onPendingPayloadEvent(payloadEvent));\n    this.sequence.pending.on(SUBSCRIPTION_EVENTS.created, createdEvent => this.onPendingStatusEvent(createdEvent));\n    this.sequence.pending.on(SUBSCRIPTION_EVENTS.updated, updatedEvent => this.onPendingStatusEvent(updatedEvent));\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.payload, payloadEvent => this.onMessage(payloadEvent));\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.created, createdEvent => {\n      const {\n        data: settled\n      } = createdEvent;\n      const eventName = this.sequence.config.events.settled;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: settled\n      });\n      this.sequence.events.emit(eventName, settled);\n    });\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.updated, updatedEvent => {\n      const {\n        data: settled,\n        update\n      } = updatedEvent;\n      const eventName = this.sequence.config.events.updated;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: settled,\n        update\n      });\n      this.sequence.events.emit(eventName, settled, update);\n    });\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.deleted, async deletedEvent => {\n      const {\n        data: settled,\n        reason\n      } = deletedEvent;\n      const eventName = this.sequence.config.events.deleted;\n      this.sequence.logger.info(`Emitting ${eventName}`);\n      this.sequence.logger.debug({\n        type: \"event\",\n        event: eventName,\n        data: settled,\n        reason\n      });\n      this.sequence.events.emit(eventName, settled, reason);\n      const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.delete, {\n        reason\n      });\n      await this.sequence.history.delete(settled.topic);\n      await this.sequence.client.relayer.publish(settled.topic, request, {\n        relay: settled.relay\n      });\n    });\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.sync, () => this.sequence.events.emit(this.sequence.config.events.sync));\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.enabled, () => this.sequence.events.emit(this.sequence.config.events.enabled));\n    this.sequence.settled.on(SUBSCRIPTION_EVENTS.disabled, () => this.sequence.events.emit(this.sequence.config.events.disabled));\n  }\n\n}","map":{"version":3,"sources":["../../../src/controllers/engine.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { IEngine, } from \"@walletconnect/types\";\nimport { generateRandomBytes32, isSignalTypePairing, isSequenceFailed, isSequenceResponded, isSubscriptionUpdatedEvent, ERROR, } from \"@walletconnect/utils\";\nimport { formatJsonRpcError, formatJsonRpcRequest, formatJsonRpcResult, isJsonRpcError, isJsonRpcRequest, } from \"@json-rpc-tools/utils\";\nimport { SUBSCRIPTION_EVENTS, RELAYER_DEFAULT_PROTOCOL, FIVE_MINUTES, THIRTY_SECONDS, } from \"../constants\";\nexport class Engine extends IEngine {\n    constructor(sequence) {\n        super(sequence);\n        this.sequence = sequence;\n        this.sequence = sequence;\n        this.registerEventListeners();\n    }\n    async ping(topic, timeout) {\n        const request = { method: this.sequence.config.jsonrpc.ping, params: {} };\n        return this.request({ topic, request, timeout: timeout || THIRTY_SECONDS * 1000 });\n    }\n    async send(topic, payload, chainId) {\n        const settled = await this.sequence.settled.get(topic);\n        if (isJsonRpcRequest(payload)) {\n            if (!Object.values(this.sequence.config.jsonrpc).includes(payload.method)) {\n                await this.isJsonRpcAuthorized(topic, settled.self, payload);\n                await this.sequence.validateRequest({ topic, request: payload, chainId });\n                await this.sequence.history.set(topic, payload, chainId);\n                const params = {\n                    chainId,\n                    request: { method: payload.method, params: payload.params },\n                };\n                if (!params.chainId)\n                    delete params.chainId;\n                payload = formatJsonRpcRequest(this.sequence.config.jsonrpc.payload, params, payload.id);\n            }\n        }\n        else {\n            await this.sequence.history.update(topic, payload);\n        }\n        await this.sequence.client.relayer.publish(settled.topic, payload, {\n            relay: settled.relay,\n        });\n    }\n    get length() {\n        return this.sequence.settled.length;\n    }\n    get topics() {\n        return this.sequence.settled.topics;\n    }\n    get values() {\n        return this.sequence.settled.values.map(x => x.data);\n    }\n    create(params) {\n        return new Promise(async (resolve, reject) => {\n            this.sequence.logger.debug(`Create ${this.sequence.context}`);\n            this.sequence.logger.trace({ type: \"method\", method: \"create\", params });\n            const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || FIVE_MINUTES * 1000;\n            const timeout = setTimeout(() => {\n                const error = ERROR.SETTLE_TIMEOUT.format({\n                    context: this.sequence.context,\n                    timeout: maxTimeout,\n                });\n                this.sequence.logger.error(error.message);\n                reject(error.message);\n            }, maxTimeout);\n            let pending;\n            try {\n                pending = await this.propose(params);\n            }\n            catch (e) {\n                clearTimeout(timeout);\n                return reject(e);\n            }\n            this.sequence.pending.on(SUBSCRIPTION_EVENTS.updated, async (updatedEvent) => {\n                if (pending.topic !== updatedEvent.data.topic)\n                    return;\n                if (isSequenceResponded(updatedEvent.data)) {\n                    const outcome = updatedEvent.data.outcome;\n                    clearTimeout(timeout);\n                    if (isSequenceFailed(outcome)) {\n                        try {\n                            await this.sequence.pending.delete(pending.topic, outcome.reason);\n                        }\n                        catch (e) {\n                            return reject(e);\n                        }\n                        reject(new Error(outcome.reason.message));\n                    }\n                    else {\n                        try {\n                            const settled = await this.sequence.settled.get(outcome.topic);\n                            const reason = ERROR.SETTLED.format({ context: this.sequence.context });\n                            await this.sequence.pending.delete(pending.topic, reason);\n                            resolve(settled);\n                        }\n                        catch (e) {\n                            return reject(e);\n                        }\n                    }\n                }\n            });\n        });\n    }\n    async respond(params) {\n        this.sequence.logger.debug(`Respond ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"respond\", params });\n        await this.sequence.validateRespond(params);\n        const { approved, proposal, response } = params;\n        const { relay, ttl } = proposal;\n        const self = {\n            publicKey: await this.sequence.client.crypto.generateKeyPair(),\n            metadata: response === null || response === void 0 ? void 0 : response.metadata,\n        };\n        if (!self.metadata)\n            delete self.metadata;\n        if (approved) {\n            try {\n                const responder = {\n                    publicKey: self.publicKey,\n                    metadata: response === null || response === void 0 ? void 0 : response.metadata,\n                };\n                if (!responder.metadata)\n                    delete responder.metadata;\n                const expiry = Date.now() + proposal.ttl * 1000;\n                const state = (response === null || response === void 0 ? void 0 : response.state) || {};\n                const peer = {\n                    publicKey: proposal.proposer.publicKey,\n                    metadata: proposal.proposer.metadata,\n                };\n                if (!peer.metadata)\n                    delete peer.metadata;\n                const controller = proposal.proposer.controller\n                    ? { publicKey: peer.publicKey }\n                    : { publicKey: self.publicKey };\n                const permissions = Object.assign(Object.assign({}, proposal.permissions), { controller });\n                const settled = await this.settle({\n                    relay,\n                    self,\n                    peer,\n                    permissions,\n                    state,\n                    ttl,\n                    expiry,\n                });\n                const outcome = {\n                    topic: settled.topic,\n                    relay,\n                    state,\n                    responder,\n                    expiry,\n                };\n                const pending = {\n                    status: this.sequence.config.status.responded,\n                    topic: proposal.topic,\n                    relay,\n                    self,\n                    proposal,\n                    outcome,\n                };\n                await this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });\n                return pending;\n            }\n            catch (e) {\n                const reason = ERROR.GENERIC.format({ message: e.message });\n                const outcome = { reason };\n                const pending = {\n                    status: this.sequence.config.status.responded,\n                    topic: proposal.topic,\n                    relay,\n                    self,\n                    proposal,\n                    outcome,\n                };\n                await this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });\n                return pending;\n            }\n        }\n        else {\n            const defaultReason = ERROR.NOT_APPROVED.format({ context: this.sequence.context });\n            const outcome = { reason: (params === null || params === void 0 ? void 0 : params.reason) || defaultReason };\n            const pending = {\n                status: this.sequence.config.status.responded,\n                topic: proposal.topic,\n                relay,\n                self,\n                proposal,\n                outcome,\n            };\n            await this.sequence.pending.set(pending.topic, pending, { relay: pending.relay });\n            return pending;\n        }\n    }\n    async update(params) {\n        this.sequence.logger.debug(`Update ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"update\", params });\n        const settled = await this.sequence.settled.get(params.topic);\n        const participant = { publicKey: settled.self.publicKey };\n        const update = await this.handleUpdate(params.topic, params, participant);\n        const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.update, update);\n        await this.send(settled.topic, request);\n        return settled;\n    }\n    async upgrade(params) {\n        this.sequence.logger.debug(`Upgrade ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"upgrade\", params });\n        const settled = await this.sequence.settled.get(params.topic);\n        const participant = { publicKey: settled.self.publicKey };\n        const upgrade = await this.handleUpgrade(params.topic, params, participant);\n        const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.upgrade, upgrade);\n        await this.send(settled.topic, request);\n        return settled;\n    }\n    async request(params) {\n        return new Promise(async (resolve, reject) => {\n            try {\n                await this.sequence.validateRequest(params);\n            }\n            catch (e) {\n                return reject(e);\n            }\n            const request = formatJsonRpcRequest(params.request.method, params.request.params);\n            const maxTimeout = (params === null || params === void 0 ? void 0 : params.timeout) || FIVE_MINUTES * 1000;\n            const timeout = setTimeout(() => {\n                const error = ERROR.JSONRPC_REQUEST_TIMEOUT.format({\n                    method: request.method,\n                    timeout: maxTimeout,\n                });\n                this.sequence.logger.error(error.message);\n                reject(error.message);\n            }, maxTimeout);\n            this.sequence.events.on(this.sequence.config.events.response, (responseEvent) => {\n                if (params.topic !== responseEvent.topic)\n                    return;\n                const response = responseEvent.response;\n                if (response.id !== request.id)\n                    return;\n                clearTimeout(timeout);\n                if (isJsonRpcError(response)) {\n                    const errorMessage = response.error.message;\n                    this.sequence.logger.error(errorMessage);\n                    return reject(new Error(errorMessage));\n                }\n                return resolve(response.result);\n            });\n            try {\n                await this.send(params.topic, request, params === null || params === void 0 ? void 0 : params.chainId);\n            }\n            catch (e) {\n                clearTimeout(timeout);\n                return reject(e);\n            }\n        });\n    }\n    async delete(params) {\n        this.sequence.logger.debug(`Delete ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"delete\", params });\n        await this.sequence.settled.delete(params.topic, params.reason);\n    }\n    async notify(params) {\n        const settled = await this.sequence.settled.get(params.topic);\n        await this.isNotificationAuthorized(params.topic, settled.self, params.type);\n        const notification = { type: params.type, data: params.data };\n        const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.notification, notification);\n        await this.send(params.topic, request);\n    }\n    async propose(params) {\n        this.sequence.logger.debug(`Propose ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"propose\", params });\n        await this.sequence.validatePropose(params);\n        const relay = (params === null || params === void 0 ? void 0 : params.relay) || { protocol: RELAYER_DEFAULT_PROTOCOL };\n        const topic = generateRandomBytes32();\n        const self = {\n            publicKey: await this.sequence.client.crypto.generateKeyPair(),\n            metadata: params === null || params === void 0 ? void 0 : params.metadata,\n        };\n        if (!self.metadata)\n            delete self.metadata;\n        const proposer = {\n            publicKey: self.publicKey,\n            controller: this.sequence.client.controller,\n            metadata: self.metadata,\n        };\n        if (!proposer.metadata)\n            delete proposer.metadata;\n        const signal = (params === null || params === void 0 ? void 0 : params.signal) || (await this.sequence.getDefaultSignal({ topic, relay, proposer }));\n        const permissions = (params === null || params === void 0 ? void 0 : params.permissions) || (await this.sequence.getDefaultPermissions());\n        const ttl = (params === null || params === void 0 ? void 0 : params.ttl) || (await this.sequence.getDefaultTTL());\n        const proposal = {\n            relay,\n            topic,\n            proposer,\n            signal,\n            permissions,\n            ttl,\n        };\n        const pending = {\n            status: this.sequence.config.status.proposed,\n            topic: proposal.topic,\n            relay: proposal.relay,\n            self,\n            proposal,\n        };\n        await this.sequence.pending.set(pending.topic, pending, { relay });\n        return pending;\n    }\n    async settle(params) {\n        this.sequence.logger.debug(`Settle ${this.sequence.context}`);\n        this.sequence.logger.trace({ type: \"method\", method: \"settle\", params });\n        const topic = await this.sequence.client.crypto.generateSharedKey(params.self, params.peer);\n        const settled = {\n            topic,\n            relay: params.relay,\n            self: params.self,\n            peer: params.peer,\n            permissions: params.permissions,\n            expiry: params.expiry,\n            state: params.state,\n        };\n        await this.sequence.settled.set(settled.topic, settled, {\n            relay: settled.relay,\n            expiry: settled.expiry,\n        });\n        return settled;\n    }\n    async onResponse(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        this.sequence.logger.debug(`Receiving ${this.sequence.context} response`);\n        this.sequence.logger.trace({ type: \"method\", method: \"onResponse\", topic, payload });\n        const request = payload;\n        const outcome = request.params;\n        const pending = await this.sequence.pending.get(topic);\n        let error;\n        if (!isSequenceFailed(outcome)) {\n            try {\n                const controller = pending.proposal.proposer.controller\n                    ? { publicKey: pending.proposal.proposer.publicKey }\n                    : { publicKey: outcome.responder.publicKey };\n                const peer = {\n                    publicKey: outcome.responder.publicKey,\n                    metadata: outcome.responder.metadata,\n                };\n                if (!peer.metadata)\n                    delete peer.metadata;\n                const state = outcome.state || {};\n                const permissions = Object.assign(Object.assign({}, pending.proposal.permissions), { controller });\n                const settled = await this.settle({\n                    relay: pending.relay,\n                    self: pending.self,\n                    peer,\n                    permissions,\n                    ttl: pending.proposal.ttl,\n                    expiry: outcome.expiry,\n                    state,\n                });\n                await this.sequence.pending.update(topic, {\n                    status: this.sequence.config.status.responded,\n                    outcome: {\n                        topic: settled.topic,\n                        relay: settled.relay,\n                        responder: outcome.responder,\n                        expiry: settled.expiry,\n                        state: settled.state,\n                    },\n                });\n            }\n            catch (e) {\n                this.sequence.logger.error(e);\n                error = ERROR.GENERIC.format({ message: e.message });\n                await this.sequence.pending.update(topic, {\n                    status: this.sequence.config.status.responded,\n                    outcome: { reason: error },\n                });\n            }\n            const response = typeof error === \"undefined\"\n                ? formatJsonRpcResult(request.id, true)\n                : formatJsonRpcError(request.id, error);\n            await this.sequence.client.relayer.publish(pending.topic, response, {\n                relay: pending.relay,\n            });\n        }\n        else {\n            this.sequence.logger.error(outcome.reason);\n            await this.sequence.pending.update(topic, {\n                status: this.sequence.config.status.responded,\n                outcome: { reason: outcome.reason },\n            });\n        }\n    }\n    async onAcknowledge(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        this.sequence.logger.debug(`Receiving ${this.sequence.context} acknowledge`);\n        this.sequence.logger.trace({ type: \"method\", method: \"onAcknowledge\", topic, payload });\n        const response = payload;\n        const pending = await this.sequence.pending.get(topic);\n        if (!isSequenceResponded(pending))\n            return;\n        if (isJsonRpcError(response) && !isSequenceFailed(pending.outcome)) {\n            await this.sequence.settled.delete(pending.outcome.topic, response.error);\n        }\n        const reason = ERROR.RESPONSE_ACKNOWLEDGED.format({ context: this.sequence.context });\n        await this.sequence.pending.delete(topic, reason);\n    }\n    async onMessage(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        this.sequence.logger.debug(`Receiving ${this.sequence.context} message`);\n        this.sequence.logger.trace({ type: \"method\", method: \"onMessage\", topic, payload });\n        if (isJsonRpcRequest(payload)) {\n            const request = payload;\n            const settled = await this.sequence.settled.get(payloadEvent.topic);\n            let error;\n            switch (request.method) {\n                case this.sequence.config.jsonrpc.payload:\n                    await this.onPayload(payloadEvent);\n                    break;\n                case this.sequence.config.jsonrpc.update:\n                    await this.onUpdate(payloadEvent);\n                    break;\n                case this.sequence.config.jsonrpc.upgrade:\n                    await this.onUpgrade(payloadEvent);\n                    break;\n                case this.sequence.config.jsonrpc.notification:\n                    await this.onNotification(payloadEvent);\n                    break;\n                case this.sequence.config.jsonrpc.delete:\n                    await this.sequence.settled.delete(settled.topic, request.params.reason);\n                    break;\n                case this.sequence.config.jsonrpc.ping:\n                    await this.send(settled.topic, formatJsonRpcResult(request.id, true));\n                    break;\n                default:\n                    error = ERROR.UNKNOWN_JSONRPC_METHOD.format({ method: request.method });\n                    this.sequence.logger.error(error.message);\n                    await this.send(settled.topic, formatJsonRpcError(request.id, error));\n                    break;\n            }\n        }\n        else {\n            this.onPayloadEvent(payloadEvent);\n        }\n    }\n    async onPayload(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (isJsonRpcRequest(payload)) {\n            const { id, params } = payload;\n            const { chainId } = params;\n            const request = formatJsonRpcRequest(params.request.method, params.request.params, id);\n            const settled = await this.sequence.settled.get(topic);\n            await this.isJsonRpcAuthorized(topic, settled.peer, request);\n            await this.sequence.validateRequest({ topic, request, chainId });\n            const settledPayloadEvent = {\n                topic,\n                payload: request,\n                chainId,\n            };\n            this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);\n            this.sequence.logger.trace(Object.assign({ type: \"method\", method: \"onPayload\" }, settledPayloadEvent));\n            this.onPayloadEvent(settledPayloadEvent);\n        }\n        else {\n            const settledPayloadEvent = {\n                topic,\n                payload,\n            };\n            this.sequence.logger.debug(`Receiving ${this.sequence.context} payload`);\n            this.sequence.logger.trace(Object.assign({ type: \"method\", method: \"onPayload\" }, settledPayloadEvent));\n            this.onPayloadEvent(settledPayloadEvent);\n        }\n    }\n    async onUpdate(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        this.sequence.logger.debug(`Receiving ${this.sequence.context} update`);\n        this.sequence.logger.trace({ type: \"method\", method: \"onUpdate\", topic, payload });\n        const request = payloadEvent.payload;\n        const settled = await this.sequence.settled.get(payloadEvent.topic);\n        try {\n            const participant = { publicKey: settled.peer.publicKey };\n            await this.handleUpdate(topic, request.params, participant);\n            const response = formatJsonRpcResult(request.id, true);\n            await this.send(settled.topic, response);\n        }\n        catch (e) {\n            this.sequence.logger.error(e);\n            const response = formatJsonRpcError(request.id, e.message);\n            await this.send(settled.topic, response);\n        }\n    }\n    async onUpgrade(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        this.sequence.logger.debug(`Receiving ${this.sequence.context} upgrade`);\n        this.sequence.logger.trace({ type: \"method\", method: \"onUpgrade\", topic, payload });\n        const request = payloadEvent.payload;\n        const settled = await this.sequence.settled.get(payloadEvent.topic);\n        try {\n            const participant = { publicKey: settled.peer.publicKey };\n            await this.handleUpgrade(topic, request.params, participant);\n            const response = formatJsonRpcResult(request.id, true);\n            await this.send(settled.topic, response);\n        }\n        catch (e) {\n            this.sequence.logger.error(e);\n            const response = formatJsonRpcError(request.id, e.message);\n            await this.send(settled.topic, response);\n        }\n    }\n    async onNotification(event) {\n        const notification = event.payload.params;\n        const settled = await this.sequence.settled.get(event.topic);\n        await this.isNotificationAuthorized(event.topic, settled.peer, notification.type);\n        const notificationEvent = {\n            topic: event.topic,\n            type: notification.type,\n            data: notification.data,\n        };\n        const eventName = this.sequence.config.events.notification;\n        this.sequence.logger.info(`Emitting ${eventName}`);\n        this.sequence.logger.debug({ type: \"event\", event: eventName, notificationEvent });\n        this.sequence.events.emit(eventName, notificationEvent);\n    }\n    async handleUpdate(topic, update, participant) {\n        if (typeof update.state === \"undefined\") {\n            const error = ERROR.INVALID_UPDATE_REQUEST.format({ context: this.sequence.context });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        const settled = await this.sequence.settled.get(topic);\n        if (participant.publicKey !== settled.permissions.controller.publicKey) {\n            const error = ERROR.UNAUTHORIZED_UPDATE_REQUEST.format({\n                context: this.sequence.context,\n            });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        settled.state = await this.sequence.mergeUpdate(topic, update);\n        await this.sequence.settled.update(settled.topic, settled);\n        return update;\n    }\n    async handleUpgrade(topic, upgrade, participant) {\n        if (typeof upgrade.permissions === \"undefined\") {\n            const error = ERROR.INVALID_UPGRADE_REQUEST.format({ context: this.sequence.context });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        const settled = await this.sequence.settled.get(topic);\n        if (participant.publicKey !== settled.permissions.controller.publicKey) {\n            const error = ERROR.UNAUTHORIZED_UPGRADE_REQUEST.format({\n                context: this.sequence.context,\n            });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n        settled.permissions = await this.sequence.mergeUpgrade(topic, upgrade);\n        await this.sequence.settled.update(settled.topic, settled);\n        return upgrade;\n    }\n    async isJsonRpcAuthorized(topic, participant, request) {\n        const settled = await this.sequence.settled.get(topic);\n        if (participant.publicKey === settled.permissions.controller.publicKey)\n            return;\n        if (!settled.permissions.jsonrpc.methods.includes(request.method)) {\n            const error = ERROR.UNAUTHORIZED_JSON_RPC_METHOD.format({\n                method: request.method,\n            });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n    }\n    async isNotificationAuthorized(topic, participant, type) {\n        const settled = await this.sequence.settled.get(topic);\n        if (participant.publicKey === settled.permissions.controller.publicKey)\n            return;\n        if (settled.self.publicKey !== settled.permissions.controller.publicKey &&\n            !settled.permissions.notifications.types.includes(type)) {\n            const error = ERROR.UNAUTHORIZED_NOTIFICATION_TYPE.format({ type });\n            this.sequence.logger.error(error.message);\n            throw new Error(error.message);\n        }\n    }\n    async shouldIgnorePayloadEvent(payloadEvent) {\n        const { topic, payload } = payloadEvent;\n        if (!this.sequence.settled.subscriptions.has(topic))\n            return true;\n        let exists = false;\n        try {\n            exists = await this.sequence.history.exists(topic, payload.id);\n        }\n        catch (e) {\n        }\n        return exists;\n    }\n    async onPayloadEvent(payloadEvent) {\n        const { topic, payload, chainId } = payloadEvent;\n        if (isJsonRpcRequest(payload)) {\n            if (await this.shouldIgnorePayloadEvent(payloadEvent))\n                return;\n            await this.sequence.history.set(topic, payload, chainId);\n        }\n        else {\n            await this.sequence.history.update(topic, payload);\n        }\n        if (isJsonRpcRequest(payload)) {\n            const requestEvent = { topic, request: payload, chainId };\n            const eventName = this.sequence.config.events.request;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: requestEvent });\n            this.sequence.events.emit(eventName, requestEvent);\n        }\n        else {\n            const responseEvent = { topic, response: payload, chainId };\n            const eventName = this.sequence.config.events.response;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: responseEvent });\n            this.sequence.events.emit(eventName, responseEvent);\n        }\n    }\n    async onPendingPayloadEvent(event) {\n        if (isJsonRpcRequest(event.payload)) {\n            switch (event.payload.method) {\n                case this.sequence.config.jsonrpc.approve:\n                case this.sequence.config.jsonrpc.reject:\n                    this.onResponse(event);\n                    break;\n                default:\n                    break;\n            }\n        }\n        else {\n            this.onAcknowledge(event);\n        }\n    }\n    async onPendingStatusEvent(event) {\n        const pending = event.data;\n        if (isSignalTypePairing(pending.proposal.signal)) {\n            if (!(await this.sequence.client.crypto.hasKeys(pending.proposal.topic))) {\n                const pairing = await this.sequence.client.pairing.settled.get(pending.proposal.signal.params.topic);\n                await this.sequence.client.crypto.generateSharedKey(pairing.self, pairing.peer, pending.proposal.topic);\n            }\n        }\n        if (isSequenceResponded(pending)) {\n            const eventName = this.sequence.config.events.responded;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: pending });\n            this.sequence.events.emit(eventName, pending);\n            if (!isSubscriptionUpdatedEvent(event)) {\n                const method = !isSequenceFailed(pending.outcome)\n                    ? this.sequence.config.jsonrpc.approve\n                    : this.sequence.config.jsonrpc.reject;\n                const request = formatJsonRpcRequest(method, pending.outcome);\n                await this.sequence.client.relayer.publish(pending.topic, request, {\n                    relay: pending.relay,\n                });\n            }\n        }\n        else {\n            const eventName = this.sequence.config.events.proposed;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: pending });\n            this.sequence.events.emit(eventName, pending);\n            if (isSignalTypePairing(pending.proposal.signal)) {\n                const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.propose, pending.proposal);\n                await this.sequence.client.pairing.send(pending.proposal.signal.params.topic, request);\n            }\n        }\n    }\n    registerEventListeners() {\n        this.sequence.pending.on(SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onPendingPayloadEvent(payloadEvent));\n        this.sequence.pending.on(SUBSCRIPTION_EVENTS.created, (createdEvent) => this.onPendingStatusEvent(createdEvent));\n        this.sequence.pending.on(SUBSCRIPTION_EVENTS.updated, (updatedEvent) => this.onPendingStatusEvent(updatedEvent));\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.payload, (payloadEvent) => this.onMessage(payloadEvent));\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.created, (createdEvent) => {\n            const { data: settled } = createdEvent;\n            const eventName = this.sequence.config.events.settled;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: settled });\n            this.sequence.events.emit(eventName, settled);\n        });\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.updated, (updatedEvent) => {\n            const { data: settled, update } = updatedEvent;\n            const eventName = this.sequence.config.events.updated;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: settled, update });\n            this.sequence.events.emit(eventName, settled, update);\n        });\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.deleted, async (deletedEvent) => {\n            const { data: settled, reason } = deletedEvent;\n            const eventName = this.sequence.config.events.deleted;\n            this.sequence.logger.info(`Emitting ${eventName}`);\n            this.sequence.logger.debug({ type: \"event\", event: eventName, data: settled, reason });\n            this.sequence.events.emit(eventName, settled, reason);\n            const request = formatJsonRpcRequest(this.sequence.config.jsonrpc.delete, { reason });\n            await this.sequence.history.delete(settled.topic);\n            await this.sequence.client.relayer.publish(settled.topic, request, {\n                relay: settled.relay,\n            });\n        });\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.sync, () => this.sequence.events.emit(this.sequence.config.events.sync));\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.enabled, () => this.sequence.events.emit(this.sequence.config.events.enabled));\n        this.sequence.settled.on(SUBSCRIPTION_EVENTS.disabled, () => this.sequence.events.emit(this.sequence.config.events.disabled));\n    }\n}\n//# sourceMappingURL=engine.js.map"]},"metadata":{},"sourceType":"module"}