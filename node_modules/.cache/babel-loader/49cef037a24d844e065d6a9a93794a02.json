{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport { generateChildLogger } from \"@pedrouid/pino-utils\";\nimport { IRelayer } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"relay-provider\";\nimport { formatRelayRpcUrl } from \"@walletconnect/utils\";\nimport { utf8ToHex, hexToUtf8 } from \"enc-utils\";\nimport { isJsonRpcRequest, formatJsonRpcResult } from \"@json-rpc-tools/utils\";\nimport { JsonRpcProvider } from \"@json-rpc-tools/provider\";\nimport { WsConnection } from \"@json-rpc-tools/ws-connection\";\nimport { safeJsonParse, safeJsonStringify } from \"safe-json-utils\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS } from \"../constants\";\nexport class Relayer extends IRelayer {\n  constructor(client, logger, provider) {\n    super(client, logger);\n    this.client = client;\n    this.logger = logger;\n    this.events = new EventEmitter();\n    this.context = RELAYER_CONTEXT;\n    this.logger = generateChildLogger(logger, this.context);\n    this.provider = this.setProvider(provider);\n    this.registerEventListeners();\n  }\n\n  get connected() {\n    return this.provider.connection.connected;\n  }\n\n  async init() {\n    this.logger.trace(`Initialized`);\n    await this.provider.connect();\n  }\n\n  async publish(topic, payload, opts) {\n    this.logger.debug(`Publishing Payload`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"publish\",\n      params: {\n        topic,\n        payload,\n        opts\n      }\n    });\n\n    try {\n      const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n      const msg = safeJsonStringify(payload);\n      const hasKeys = await this.client.crypto.hasKeys(topic);\n      const message = hasKeys ? await this.client.crypto.encrypt(topic, msg) : utf8ToHex(msg);\n      const jsonRpc = getRelayProtocolJsonRpc(protocol);\n      const request = {\n        method: jsonRpc.publish,\n        params: {\n          topic,\n          message,\n          ttl: (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL\n        }\n      };\n      this.logger.debug(`Outgoing Relay Payload`);\n      this.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request\n      });\n      await this.provider.request(request);\n      this.logger.debug(`Successfully Published Payload`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"publish\",\n        request\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Publish Payload`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async subscribe(topic, listener, opts) {\n    this.logger.debug(`Subscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"subscribe\",\n      params: {\n        topic,\n        opts\n      }\n    });\n\n    try {\n      const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n      const jsonRpc = getRelayProtocolJsonRpc(protocol);\n      const request = {\n        method: jsonRpc.subscribe,\n        params: {\n          topic\n        }\n      };\n      this.logger.debug(`Outgoing Relay Payload`);\n      this.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request\n      });\n      const id = await this.provider.request(request);\n      this.events.on(id, async ({\n        message\n      }) => {\n        const hasKeys = await this.client.crypto.hasKeys(topic);\n        const payload = safeJsonParse(hasKeys ? await this.client.crypto.decrypt(topic, message) : hexToUtf8(message));\n        listener(payload);\n      });\n      this.logger.debug(`Successfully Subscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"subscribe\",\n        request\n      });\n      return id;\n    } catch (e) {\n      this.logger.debug(`Failed to Subscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  async unsubscribe(id, opts) {\n    this.logger.debug(`Unsubscribing Topic`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"unsubscribe\",\n      params: {\n        id,\n        opts\n      }\n    });\n\n    try {\n      const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n      const jsonRpc = getRelayProtocolJsonRpc(protocol);\n      const request = {\n        method: jsonRpc.unsubscribe,\n        params: {\n          id\n        }\n      };\n      this.logger.debug(`Outgoing Relay Payload`);\n      this.logger.trace({\n        type: \"payload\",\n        direction: \"outgoing\",\n        request\n      });\n      await this.provider.request(request);\n      this.events.removeAllListeners(id);\n      this.logger.debug(`Successfully Unsubscribed Topic`);\n      this.logger.trace({\n        type: \"method\",\n        method: \"unsubscribe\",\n        request\n      });\n    } catch (e) {\n      this.logger.debug(`Failed to Unsubscribe Topic`);\n      this.logger.error(e);\n      throw e;\n    }\n  }\n\n  on(event, listener) {\n    this.events.on(event, listener);\n  }\n\n  once(event, listener) {\n    this.events.once(event, listener);\n  }\n\n  off(event, listener) {\n    this.events.off(event, listener);\n  }\n\n  removeListener(event, listener) {\n    this.events.removeListener(event, listener);\n  }\n\n  onPayload(payload) {\n    this.logger.debug(`Incoming Relay Payload`);\n    this.logger.trace({\n      type: \"payload\",\n      direction: \"incoming\",\n      payload\n    });\n\n    if (isJsonRpcRequest(payload)) {\n      if (payload.method.endsWith(\"_subscription\")) {\n        const event = payload.params;\n        this.events.emit(event.id, event.data);\n        const response = formatJsonRpcResult(payload.id, true);\n        this.provider.connection.send(response);\n      }\n    }\n  }\n\n  setProvider(provider) {\n    this.logger.debug(`Setting Relay Provider`);\n    this.logger.trace({\n      type: \"method\",\n      method: \"setProvider\",\n      provider: provider === null || provider === void 0 ? void 0 : provider.toString()\n    });\n    const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === \"string\" ? provider : RELAYER_DEFAULT_RPC_URL);\n    return typeof provider !== \"string\" && typeof provider !== \"undefined\" ? provider : new JsonRpcProvider(new WsConnection(rpcUrl));\n  }\n\n  registerEventListeners() {\n    this.provider.on(\"payload\", payload => this.onPayload(payload));\n    this.provider.on(\"connect\", () => this.events.emit(RELAYER_EVENTS.connect));\n    this.provider.on(\"disconnect\", () => {\n      this.events.emit(RELAYER_EVENTS.disconnect);\n      this.provider.connect();\n    });\n    this.provider.on(\"error\", e => this.events.emit(RELAYER_EVENTS.error, e));\n  }\n\n}\n\nfunction getRelayProtocolJsonRpc(protocol) {\n  const jsonrpc = RELAY_JSONRPC[protocol];\n\n  if (typeof jsonrpc === \"undefined\") {\n    throw new Error(`Relay Protocol not supported: ${protocol}`);\n  }\n\n  return jsonrpc;\n}","map":{"version":3,"sources":["../../../src/controllers/relayer.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["import { EventEmitter } from \"events\";\nimport { generateChildLogger } from \"@pedrouid/pino-utils\";\nimport { IRelayer } from \"@walletconnect/types\";\nimport { RELAY_JSONRPC } from \"relay-provider\";\nimport { formatRelayRpcUrl } from \"@walletconnect/utils\";\nimport { utf8ToHex, hexToUtf8 } from \"enc-utils\";\nimport { isJsonRpcRequest, formatJsonRpcResult, } from \"@json-rpc-tools/utils\";\nimport { JsonRpcProvider } from \"@json-rpc-tools/provider\";\nimport { WsConnection } from \"@json-rpc-tools/ws-connection\";\nimport { safeJsonParse, safeJsonStringify } from \"safe-json-utils\";\nimport { RELAYER_CONTEXT, RELAYER_DEFAULT_PROTOCOL, RELAYER_DEFAULT_RPC_URL, RELAYER_DEFAULT_PUBLISH_TTL, RELAYER_EVENTS, } from \"../constants\";\nexport class Relayer extends IRelayer {\n    constructor(client, logger, provider) {\n        super(client, logger);\n        this.client = client;\n        this.logger = logger;\n        this.events = new EventEmitter();\n        this.context = RELAYER_CONTEXT;\n        this.logger = generateChildLogger(logger, this.context);\n        this.provider = this.setProvider(provider);\n        this.registerEventListeners();\n    }\n    get connected() {\n        return this.provider.connection.connected;\n    }\n    async init() {\n        this.logger.trace(`Initialized`);\n        await this.provider.connect();\n    }\n    async publish(topic, payload, opts) {\n        this.logger.debug(`Publishing Payload`);\n        this.logger.trace({ type: \"method\", method: \"publish\", params: { topic, payload, opts } });\n        try {\n            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n            const msg = safeJsonStringify(payload);\n            const hasKeys = await this.client.crypto.hasKeys(topic);\n            const message = hasKeys ? await this.client.crypto.encrypt(topic, msg) : utf8ToHex(msg);\n            const jsonRpc = getRelayProtocolJsonRpc(protocol);\n            const request = {\n                method: jsonRpc.publish,\n                params: {\n                    topic,\n                    message,\n                    ttl: (opts === null || opts === void 0 ? void 0 : opts.ttl) || RELAYER_DEFAULT_PUBLISH_TTL,\n                },\n            };\n            this.logger.debug(`Outgoing Relay Payload`);\n            this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n            await this.provider.request(request);\n            this.logger.debug(`Successfully Published Payload`);\n            this.logger.trace({ type: \"method\", method: \"publish\", request });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Publish Payload`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async subscribe(topic, listener, opts) {\n        this.logger.debug(`Subscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"subscribe\", params: { topic, opts } });\n        try {\n            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n            const jsonRpc = getRelayProtocolJsonRpc(protocol);\n            const request = {\n                method: jsonRpc.subscribe,\n                params: {\n                    topic,\n                },\n            };\n            this.logger.debug(`Outgoing Relay Payload`);\n            this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n            const id = await this.provider.request(request);\n            this.events.on(id, async ({ message }) => {\n                const hasKeys = await this.client.crypto.hasKeys(topic);\n                const payload = safeJsonParse(hasKeys ? await this.client.crypto.decrypt(topic, message) : hexToUtf8(message));\n                listener(payload);\n            });\n            this.logger.debug(`Successfully Subscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"subscribe\", request });\n            return id;\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Subscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    async unsubscribe(id, opts) {\n        this.logger.debug(`Unsubscribing Topic`);\n        this.logger.trace({ type: \"method\", method: \"unsubscribe\", params: { id, opts } });\n        try {\n            const protocol = (opts === null || opts === void 0 ? void 0 : opts.relay.protocol) || RELAYER_DEFAULT_PROTOCOL;\n            const jsonRpc = getRelayProtocolJsonRpc(protocol);\n            const request = {\n                method: jsonRpc.unsubscribe,\n                params: {\n                    id,\n                },\n            };\n            this.logger.debug(`Outgoing Relay Payload`);\n            this.logger.trace({ type: \"payload\", direction: \"outgoing\", request });\n            await this.provider.request(request);\n            this.events.removeAllListeners(id);\n            this.logger.debug(`Successfully Unsubscribed Topic`);\n            this.logger.trace({ type: \"method\", method: \"unsubscribe\", request });\n        }\n        catch (e) {\n            this.logger.debug(`Failed to Unsubscribe Topic`);\n            this.logger.error(e);\n            throw e;\n        }\n    }\n    on(event, listener) {\n        this.events.on(event, listener);\n    }\n    once(event, listener) {\n        this.events.once(event, listener);\n    }\n    off(event, listener) {\n        this.events.off(event, listener);\n    }\n    removeListener(event, listener) {\n        this.events.removeListener(event, listener);\n    }\n    onPayload(payload) {\n        this.logger.debug(`Incoming Relay Payload`);\n        this.logger.trace({ type: \"payload\", direction: \"incoming\", payload });\n        if (isJsonRpcRequest(payload)) {\n            if (payload.method.endsWith(\"_subscription\")) {\n                const event = payload.params;\n                this.events.emit(event.id, event.data);\n                const response = formatJsonRpcResult(payload.id, true);\n                this.provider.connection.send(response);\n            }\n        }\n    }\n    setProvider(provider) {\n        this.logger.debug(`Setting Relay Provider`);\n        this.logger.trace({ type: \"method\", method: \"setProvider\", provider: provider === null || provider === void 0 ? void 0 : provider.toString() });\n        const rpcUrl = formatRelayRpcUrl(this.client.protocol, this.client.version, typeof provider === \"string\" ? provider : RELAYER_DEFAULT_RPC_URL);\n        return typeof provider !== \"string\" && typeof provider !== \"undefined\"\n            ? provider\n            : new JsonRpcProvider(new WsConnection(rpcUrl));\n    }\n    registerEventListeners() {\n        this.provider.on(\"payload\", (payload) => this.onPayload(payload));\n        this.provider.on(\"connect\", () => this.events.emit(RELAYER_EVENTS.connect));\n        this.provider.on(\"disconnect\", () => {\n            this.events.emit(RELAYER_EVENTS.disconnect);\n            this.provider.connect();\n        });\n        this.provider.on(\"error\", e => this.events.emit(RELAYER_EVENTS.error, e));\n    }\n}\nfunction getRelayProtocolJsonRpc(protocol) {\n    const jsonrpc = RELAY_JSONRPC[protocol];\n    if (typeof jsonrpc === \"undefined\") {\n        throw new Error(`Relay Protocol not supported: ${protocol}`);\n    }\n    return jsonrpc;\n}\n//# sourceMappingURL=relayer.js.map"]},"metadata":{},"sourceType":"module"}