import { JsonRpcPayload, JsonRpcRequest, JsonRpcResponse, RequestArguments } from "@json-rpc-tools/types";
import { ISequence } from "./sequence";
import { CryptoTypes } from "./crypto";
import { RelayerTypes } from "./relayer";
import { AppMetadata, JsonRpcPermissions, Reason, SignalTypes } from "./misc";
export declare namespace PairingTypes {
    interface BasePermissions {
        jsonrpc: JsonRpcPermissions;
    }
    type ProposedPermissions = BasePermissions;
    interface SettledPermissions extends ProposedPermissions {
        controller: CryptoTypes.Participant;
    }
    type Permissions = SettledPermissions;
    interface ProposeParams {
        relay: RelayerTypes.ProtocolOptions;
        timeout?: number;
    }
    type CreateParams = ProposeParams;
    type Signal = SignalTypes.Uri;
    type Peer = CryptoTypes.Participant;
    interface ProposedPeer extends Peer {
        controller: boolean;
    }
    interface Proposal {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        proposer: ProposedPeer;
        signal: Signal;
        permissions: ProposedPermissions;
        ttl: number;
    }
    type ProposedStatus = "proposed";
    type RespondedStatus = "responded";
    type PendingStatus = ProposedStatus | RespondedStatus;
    interface BasePending {
        status: PendingStatus;
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        self: CryptoTypes.Self;
        proposal: Proposal;
    }
    interface ProposedPending extends BasePending {
        status: ProposedStatus;
    }
    interface RespondedPending extends BasePending {
        status: RespondedStatus;
        outcome: Outcome;
    }
    type Pending = ProposedPending | RespondedPending;
    interface RespondParams {
        approved: boolean;
        proposal: Proposal;
        reason?: Reason;
    }
    interface SettleParams {
        relay: RelayerTypes.ProtocolOptions;
        peer: Peer;
        self: CryptoTypes.Self;
        state: State;
        permissions: SettledPermissions;
        ttl: number;
        expiry: number;
    }
    interface UpgradeParams extends Upgrade {
        topic: string;
    }
    interface UpdateParams extends Update {
        topic: string;
    }
    interface RequestParams {
        topic: string;
        request: RequestArguments;
        timeout?: number;
    }
    interface Upgrade {
        permissions: Partial<Permissions>;
    }
    interface Update {
        state: Partial<State>;
    }
    interface Payload {
        request: RequestArguments;
    }
    interface PayloadEvent {
        topic: string;
        payload: JsonRpcPayload;
    }
    interface RequestEvent extends Omit<PayloadEvent, "payload"> {
        request: JsonRpcRequest;
    }
    interface ResponseEvent extends Omit<PayloadEvent, "payload"> {
        response: JsonRpcResponse;
    }
    interface DeleteParams {
        topic: string;
        reason: Reason;
    }
    interface Settled {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        sharedKey: string;
        self: CryptoTypes.Self;
        peer: Peer;
        permissions: SettledPermissions;
        expiry: number;
        state: State;
    }
    type Created = Settled;
    interface Success {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        responder: Peer;
        expiry: number;
        state: State;
    }
    interface Failed {
        reason: Reason;
    }
    type Outcome = Failed | Success;
    interface State {
        metadata?: AppMetadata;
    }
}
export declare abstract class IPairing extends ISequence<PairingTypes.Pending, PairingTypes.Settled, PairingTypes.Upgrade, PairingTypes.Update, PairingTypes.CreateParams, PairingTypes.RespondParams, PairingTypes.RequestParams, PairingTypes.UpgradeParams, PairingTypes.UpdateParams, PairingTypes.DeleteParams, PairingTypes.ProposeParams, PairingTypes.SettleParams> {
}
//# sourceMappingURL=pairing.d.ts.map