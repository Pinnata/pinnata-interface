import { JsonRpcPayload, JsonRpcRequest, JsonRpcResponse, RequestArguments } from "@json-rpc-tools/types";
import { ISequence } from "./sequence";
import { CryptoTypes } from "./crypto";
import { RelayerTypes } from "./relayer";
import { SignalTypes, BlockchainTypes, JsonRpcPermissions, NotificationPermissions, AppMetadata, Reason } from "./misc";
import { SubscriptionEvent } from "./subscription";
export declare namespace SessionTypes {
    interface BasePermissions {
        jsonrpc: JsonRpcPermissions;
        blockchain: BlockchainTypes.Permissions;
        notifications?: NotificationPermissions;
    }
    interface ProposedPermissions extends BasePermissions {
        notifications: NotificationPermissions;
    }
    interface SettledPermissions extends ProposedPermissions {
        controller: CryptoTypes.Participant;
    }
    type Permissions = SettledPermissions;
    interface ProposeParams {
        signal: Signal;
        relay: RelayerTypes.ProtocolOptions;
        metadata: AppMetadata;
        permissions: ProposedPermissions;
        ttl?: number;
        timeout?: number;
    }
    type CreateParams = ProposeParams;
    type Signal = SignalTypes.Pairing;
    type Peer = Required<CryptoTypes.Peer<AppMetadata>>;
    interface ProposedPeer extends Peer {
        controller: boolean;
    }
    interface Proposal {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        proposer: ProposedPeer;
        signal: Signal;
        permissions: ProposedPermissions;
        ttl: number;
    }
    type ProposedStatus = "proposed";
    type RespondedStatus = "responded";
    type PendingStatus = ProposedStatus | RespondedStatus;
    interface BasePending {
        status: PendingStatus;
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        self: CryptoTypes.Self;
        proposal: Proposal;
    }
    interface ProposedPending extends BasePending {
        status: ProposedStatus;
    }
    interface RespondedPending extends BasePending {
        status: RespondedStatus;
        outcome: Outcome;
    }
    type Pending = ProposedPending | RespondedPending;
    interface RespondParams {
        approved: boolean;
        proposal: Proposal;
        response: Response;
        reason?: Reason;
    }
    interface SettleParams {
        relay: RelayerTypes.ProtocolOptions;
        self: CryptoTypes.Self;
        peer: Peer;
        state: State;
        permissions: SettledPermissions;
        ttl: number;
        expiry: number;
    }
    interface UpgradeParams extends Upgrade {
        topic: string;
    }
    interface UpdateParams extends Update {
        topic: string;
    }
    interface RequestParams {
        topic: string;
        request: RequestArguments;
        chainId?: string;
        timeout?: number;
    }
    interface Upgrade {
        permissions: Partial<BasePermissions>;
    }
    interface Update {
        state: Partial<State>;
    }
    interface Payload {
        request: RequestArguments;
        chainId?: string;
    }
    interface PayloadEvent {
        topic: string;
        payload: JsonRpcPayload;
        chainId?: string;
    }
    interface RequestEvent extends Omit<PayloadEvent, "payload"> {
        request: JsonRpcRequest;
    }
    interface ResponseEvent extends Omit<PayloadEvent, "payload"> {
        response: JsonRpcResponse;
    }
    interface Notification {
        type: string;
        data: any;
    }
    interface NotificationEvent extends Notification {
        topic: string;
    }
    type NotifyParams = NotificationEvent;
    interface DeleteParams {
        topic: string;
        reason: Reason;
    }
    interface Settled {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        sharedKey: string;
        self: CryptoTypes.Self;
        peer: Peer;
        permissions: SettledPermissions;
        expiry: number;
        state: State;
    }
    type Created = Settled;
    interface Success {
        topic: string;
        relay: RelayerTypes.ProtocolOptions;
        responder: Peer;
        expiry: number;
        state: State;
    }
    interface Failed {
        reason: Reason;
    }
    type Outcome = Failed | Success;
    type State = BlockchainTypes.State;
    interface Response {
        state: State;
        metadata: AppMetadata;
    }
}
export declare abstract class ISession extends ISequence<SessionTypes.Pending, SessionTypes.Settled, SessionTypes.Upgrade, SessionTypes.Update, SessionTypes.CreateParams, SessionTypes.RespondParams, SessionTypes.RequestParams, SessionTypes.UpgradeParams, SessionTypes.UpdateParams, SessionTypes.DeleteParams, SessionTypes.ProposeParams, SessionTypes.SettleParams> {
    abstract send(topic: string, payload: JsonRpcPayload, chainId?: string): Promise<void>;
    abstract notify(params: SessionTypes.NotifyParams): Promise<void>;
    protected abstract onNotification(event: SubscriptionEvent.Payload): Promise<void>;
}
//# sourceMappingURL=session.d.ts.map