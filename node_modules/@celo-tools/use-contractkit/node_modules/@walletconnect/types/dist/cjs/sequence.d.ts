import { Logger } from "pino";
import { JsonRpcPayload, IEvents } from "@json-rpc-tools/types";
import { IClient } from "./client";
import { CryptoTypes } from "./crypto";
import { ISubscription, SubscriptionEvent } from "./subscription";
import { IJsonRpcHistory } from "./history";
export declare abstract class ISequence<Pending, Settled, Upgrade, Update, CreateParams, RespondParams, RequestParams, UpgradeParams, UpdateParams, DeleteParams, ProposeParams, SettleParams> extends IEvents {
    client: IClient;
    logger: Logger;
    abstract pending: ISubscription<Pending>;
    abstract settled: ISubscription<Settled>;
    abstract history: IJsonRpcHistory;
    abstract readonly length: number;
    abstract readonly topics: string[];
    abstract readonly values: Settled[];
    protected abstract context: string;
    constructor(client: IClient, logger: Logger);
    abstract init(): Promise<void>;
    abstract get(topic: string): Promise<Settled>;
    abstract ping(topic: string, timeout?: number): Promise<void>;
    abstract send(topic: string, payload: JsonRpcPayload): Promise<void>;
    abstract create(params?: CreateParams): Promise<Settled>;
    abstract respond(params: RespondParams): Promise<Pending>;
    abstract request(params: RequestParams): Promise<any>;
    abstract upgrade(params: UpgradeParams): Promise<Settled>;
    abstract update(params: UpdateParams): Promise<Settled>;
    abstract delete(params: DeleteParams): Promise<void>;
    protected abstract propose(params?: ProposeParams): Promise<Pending>;
    protected abstract settle(params: SettleParams): Promise<Settled>;
    protected abstract onResponse(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract onAcknowledge(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract onMessage(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract onPayload(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract onUpdate(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract onUpgrade(payloadEvent: SubscriptionEvent.Payload): Promise<void>;
    protected abstract handleUpdate(topic: string, update: Update, participant: CryptoTypes.Participant): Promise<Update>;
    protected abstract handleUpgrade(topic: string, params: Upgrade, participant: CryptoTypes.Participant): Promise<Upgrade>;
}
//# sourceMappingURL=sequence.d.ts.map